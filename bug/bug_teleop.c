#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,                    sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     LeftFront,     tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     RightFront,    tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     LeftPair,      tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     RightPair,     tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     frontArmMotor, tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     rearArmMotor,  tmotorNormal, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    RightGripper,         tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    LeftGripper,          tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    SuckyLeft,            tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C4_4,    SuckyRight,           tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoStandard)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Tele-Operation Mode Code Template
//
// This file contains a template for simplified creation of an tele-op program for an FTC
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

/* structure used to keep track of desired rotational angle for arm, gripper, etc.
   Use angular units appropriate to the corresponding device */
typedef struct {
  int command;            /* commanded angle */
  long lastUpdateTime;    /* time at which commanded angle was last updated */
  int changeRate;         /* rate at which angle should change in units per sec */
  int posLimit;           /* positive limit for commanded angle */
  int negLimit;           /* negative limit for commanded angle */
} angle;

/* structure to keep track of the state of a button, or joystick if used in a
   button-like manner */
typedef struct {
  int state;      /* true if button was pressed at last check */
  long time;      /* time button was initially pressed */
} click;

#define CLICK_DURATION              150

#define JOYSTICK_DEADBAND           30
#define JOYSTICK_LOW                90

#define DRIVE_MOTOR_RATE_LOW        20
#define DRIVE_MOTOR_RATE_HIGH       100

#define FRONT_ARM_MOTOR_RATE_LOW    25
#define FRONT_ARM_MOTOR_RATE_HIGH   100

#define FRONT_ARM_INTERVAL          150   /* duration of low motor power, msec */

#define GRIPPER_NUDGE_INCREMENT     10
#define GRIPPER_CHANGE_RATE         96
#define GRIPPER_LEFT_LOW_CONFLICT   65
#define GRIPPER_LEFT_HIGH_CONFLICT  180
#define GRIPPER_RIGHT_LOW_CONFLICT  75
#define GRIPPER_RIGHT_HIGH_CONFLICT 190

#define REAR_ARM_MOTOR_RATE_LOW     25
#define REAR_ARM_MOTOR_RATE_HIGH    40

#define REAR_ARM_INTERVAL           150   /* duration of low motor power, msec */

#define SUCKY_STATE_OFF 0
#define SUCKY_STATE_IN  1
#define SUCKY_STATE_OUT 2

#define SUCKY_SERVO_OFF 128
#define SUCKY_SERVO_CCW   1
#define SUCKY_SERVO_CW  255

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of tele-op mode, you may want to perform some initialization on your robot
// and the variables within your program.
//
// In most cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{
  // Place code here to sinitialize servos to starting positions.
  // Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.

  return;
}



void driveControl(click *ccwClick, click *cwClick, click *fwClick, click *bwClick)
{
  /* Drive robot with left and right joysticks.  Joystick movements are incremental,
     with three thresholds and three power levels.  Maximum joystick movement results
     in highest power to motors.

     Left joystick left/right controls spin (yaw) of robot.
     Right joystick forward/back controls forward/backward movement

      - left hold of left joystick spins robot counter-clockwise
      - right hold of left joystick spins robot clockwise
      - forward hold of right joystick moves robot forward
      - backward hold of right joystick moves robot backward */

  int leftMotorPower, rightMotorPower;

  leftMotorPower = 0;
  rightMotorPower = 0;

  if (joystick.joy1_y2 > JOYSTICK_LOW) {
    /* right joystick is pushed forward into high power range */
    leftMotorPower += DRIVE_MOTOR_RATE_HIGH;
    rightMotorPower += DRIVE_MOTOR_RATE_HIGH;
  } else if (joystick.joy1_y2 > JOYSTICK_DEADBAND) {
    /* right joystick is pushed forward into lowest power range */
    leftMotorPower += DRIVE_MOTOR_RATE_LOW;
    rightMotorPower += DRIVE_MOTOR_RATE_LOW;
  } else if (joystick.joy1_y2 < -JOYSTICK_LOW) {
    /* right joystick is pushed backward into high power range */
    leftMotorPower -= DRIVE_MOTOR_RATE_HIGH;
    rightMotorPower -= DRIVE_MOTOR_RATE_HIGH;
  } else if (joystick.joy1_y2 < -JOYSTICK_DEADBAND) {
    /* right joystick is pushed backword into low power range */
    leftMotorPower -= DRIVE_MOTOR_RATE_LOW;
    rightMotorPower -= DRIVE_MOTOR_RATE_LOW;
  }

  if (joystick.joy1_x1 > JOYSTICK_LOW) {
    /* right joystick is pushed right into high power range */
    leftMotorPower += DRIVE_MOTOR_RATE_HIGH;
    rightMotorPower -= DRIVE_MOTOR_RATE_HIGH;
  } else if (joystick.joy1_x1 > JOYSTICK_DEADBAND) {
    /* right joystick is pushed right into low power range */
    leftMotorPower += DRIVE_MOTOR_RATE_LOW;
    rightMotorPower -= DRIVE_MOTOR_RATE_LOW;
  } else if (joystick.joy1_x1 < -JOYSTICK_LOW) {
    /* right joystick is pushed left into high power range */
    leftMotorPower -= DRIVE_MOTOR_RATE_HIGH;
    rightMotorPower += DRIVE_MOTOR_RATE_HIGH;
  } else if (joystick.joy1_x1 < -JOYSTICK_DEADBAND) {
    /* right joystick is pushed left into low power range */
    leftMotorPower -= DRIVE_MOTOR_RATE_LOW;
    rightMotorPower += DRIVE_MOTOR_RATE_LOW;
  }

  motor[RightPair] = rightMotorPower;
  motor[RightFront] = rightMotorPower;
  motor[LeftPair] = leftMotorPower;
  motor[LeftFront] = leftMotorPower;
}

void frontArmControl(click *fwClick, click *bwClick)
{
    /* drive front arm with buttons 5 & 7. Power applied to motor
       increases with the time button is held.
		     - button 7 moves arm forward
		     - button 5 moves arm backward */

  int armMotorPower;
  long pollTime;

  armMotorPower = 0;
  pollTime = nPgmTime;

  if (joy1Btn(5)) {
    /* button 5 pressed */
    if (!fwClick->state) {
      /* wasn't clicked before, so change state to true and record time */
	    fwClick->state = true;
	    fwClick->time = pollTime;
	  }

	  /* determine motor power based on amount of time button has been pushed */
	  if (abs(pollTime - fwClick->time) > FRONT_ARM_INTERVAL) {
	    /* long enough to go to high power */
	    armMotorPower = FRONT_ARM_MOTOR_RATE_HIGH;
	  } else {
	    /* lowest power */
	    armMotorPower = FRONT_ARM_MOTOR_RATE_LOW;
	  }
	} else {
	  /* button 5 not clicked, so clear state */
    fwClick->state = false;
	}

  if (joy1Btn(7)) {
    /* button 7 pressed */
    if (!bwClick->state) {
      /* wasn't clicked before, so change state to true and record time */
	    bwClick->state = true;
	    bwClick->time = pollTime;
	  }

	  /* determine motor power based on amount of time button has been pushed */
	  if (abs(pollTime - bwClick->time) > FRONT_ARM_INTERVAL) {
	    /* long enough to go to high power */
	    armMotorPower = -FRONT_ARM_MOTOR_RATE_HIGH;
	  } else {
	    /* lowest power */
	    armMotorPower = -FRONT_ARM_MOTOR_RATE_LOW;
	  }
	} else {
	  /* button 7 not clicked, so clear state */
    bwClick->state = false;
	}

	motor[frontArmMotor] = armMotorPower;
}

void gripperControl(angle *leftAngle, angle *rightAngle, click *openClick, click *closeClick)
{
  /* drive gripper with buttons 6 & 8
     - clicking button 8 nudges gripper closed
     - holding button 8 steadily closes gripper
     - clicking button 6 nudges gripper open
     - holding button 6 steadily opens gripper */

  long pollTime;
  int increment;

  pollTime = nPgmTime;

  if (joy1Btn(8)) {
    if (!closeClick->state) {
      /* wasn't clicked before, so treat as a click and close gripper a small increment */
	    leftAngle->command -= GRIPPER_NUDGE_INCREMENT;
	    leftAngle->lastUpdateTime = pollTime;
	    rightAngle->command += GRIPPER_NUDGE_INCREMENT;
	    rightAngle->lastUpdateTime = pollTime;
	    closeClick->state = true;
	    closeClick->time = pollTime;
	  } else if (abs (pollTime - closeClick->time) > CLICK_DURATION) {
	    /* button has been held for more than the click length, so steadily close gripper*/
	    increment = (abs(pollTime - leftAngle->lastUpdateTime) * leftAngle->changeRate)/1000;
	    if (increment) {
	      leftAngle->command -= increment;
	      leftAngle->lastUpdateTime = pollTime;
	    }
	    increment = (abs(pollTime - rightAngle->lastUpdateTime) * rightAngle->changeRate)/1000;
	    if (increment) {
	      rightAngle->command += increment;
	      rightAngle->lastUpdateTime = pollTime;
	    }
	  }
	} else {
	  /* button 8 not clicked, so clear state */
    closeClick->state = false;
	}

  if (joy1Btn(6)) {
    if (!openClick->state) {
      /* wasn't clicked before, so treat as a click and open gripper a small increment */
	    leftAngle->command += GRIPPER_NUDGE_INCREMENT;
	    leftAngle->lastUpdateTime = pollTime;
	    rightAngle->command -= GRIPPER_NUDGE_INCREMENT;
	    rightAngle->lastUpdateTime = pollTime;
	    openClick->state = true;
	    openClick->time = pollTime;
	  } else if (abs (pollTime - openClick->time) > CLICK_DURATION) {
	    /* button has been held for more than the click duration, so steadily open gripper*/
	    increment = (abs(pollTime - leftAngle->lastUpdateTime) * leftAngle->changeRate)/1000;
	    if (increment) {
	      leftAngle->command += increment;
	      leftAngle->lastUpdateTime = pollTime;
	    }
	    increment = (abs(pollTime - rightAngle->lastUpdateTime) * rightAngle->changeRate)/1000;
	    if (increment) {
	      rightAngle->command -= increment;
	      rightAngle->lastUpdateTime = pollTime;
	    }
	  }
	} else {
	  /* button 6 not clicked, so clear state */
    openClick->state = false;
	}

  /* angular units translate directly to servo position units, which range from 0-255 */
  if (rightAngle->command > rightAngle->posLimit) {
    rightAngle->command = rightAngle->posLimit;
  } else if (rightAngle->command < rightAngle->negLimit) {
    rightAngle->command = rightAngle->negLimit;
  }

  if (leftAngle->command > leftAngle->posLimit) {
    leftAngle->command = leftAngle->posLimit;
  } else if (leftAngle->command < leftAngle->negLimit) {
    leftAngle->command = leftAngle->negLimit;
  }

  servo[RightGripper] = rightAngle->command;
  if (rightAngle->command < GRIPPER_RIGHT_LOW_CONFLICT ||
              rightAngle->command > GRIPPER_RIGHT_HIGH_CONFLICT) {
    servo[LeftGripper] = leftAngle->command;
  }
}

void rearArmControl(click *fwClick, click *bwClick)
{
    /* drive front arm with buttons 4 & 2
		     - clicking button 4 nudges arm forward
		     - holding button 4 moves arm steadily forward
		     - clicking button 2 nudges arm backward
		     - holding button 2 moves arm steadily backward */

  int armMotorPower;
  long pollTime;

  armMotorPower = 0;
  pollTime = nPgmTime;

  if (joy1Btn(4)) {
    /* button 4 pressed */
    if (!fwClick->state) {
      /* wasn't clicked before, so change state to true and record time */
	    fwClick->state = true;
	    fwClick->time = pollTime;
	  }

	  /* determine motor power based on amount of time button has been pushed */
	  if (abs(pollTime - fwClick->time) > REAR_ARM_INTERVAL) {
	    /* long enough to go to high power */
	    armMotorPower = REAR_ARM_MOTOR_RATE_HIGH;
	  } else {
	    /* lowest power */
	    armMotorPower = REAR_ARM_MOTOR_RATE_LOW;
	  }
	} else {
	  /* button 4 not clicked, so clear state */
    fwClick->state = false;
	}

  if (joy1Btn(2)) {
    /* button 2 pressed */
    if (!bwClick->state) {
      /* wasn't clicked before, so change state to true and record time */
	    bwClick->state = true;
	    bwClick->time = pollTime;
	  }

	  /* determine motor power based on amount of time button has been pushed */
	  if (abs(pollTime - bwClick->time) > REAR_ARM_INTERVAL) {
	    /* long enough to go to high power */
	    armMotorPower = -REAR_ARM_MOTOR_RATE_HIGH;
	  } else {
	    /* lowest power */
	    armMotorPower = -REAR_ARM_MOTOR_RATE_LOW;
	  }
	} else {
	  /* button 2 not clicked, so clear state */
    bwClick->state = false;
	}

	motor[rearArmMotor] = armMotorPower;
}

int suckyControl(int suckyState, click *inClick, click *outClick)
{
  /* control ball-sucking wheels with buttons 1 & 3
     - button 1 toggles inward suck
     - button 3 toggles outward spew */

  /* check for unclicks */
  if (joy1Btn(1) != 1 && inClick->state) {
    inClick->state = false;
    inClick->time = nPgmTime;
  }

  if (joy1Btn(3) != 1 && outClick->state) {
    outClick->state = false;
    outClick->time = nPgmTime;
  }

  switch (suckyState) {
    case SUCKY_STATE_OFF:
		  if (joy1Btn(1) == 1 && !inClick->state) {
		    servo[SuckyRight] = SUCKY_SERVO_CW;
		    servo[SuckyLeft]= SUCKY_SERVO_CCW;
		    suckyState = SUCKY_STATE_IN;
		    inClick->state = true;
		    inClick->time = nPgmTime;
		  } else if (joy1Btn(3) == 1 && !outClick->state) {
		    servo[SuckyRight] = SUCKY_SERVO_CCW;
		    servo[SuckyLeft]= SUCKY_SERVO_CW;
		    suckyState = SUCKY_STATE_OUT;
		    outClick->state = true;
		    outClick->time = nPgmTime;
		  }
		  break;

		case SUCKY_STATE_IN:
		  if (joy1Btn(1) == 1 && !inClick->state) {
		    servo[SuckyRight] = SUCKY_SERVO_OFF;
		    servo[SuckyLeft] = SUCKY_SERVO_OFF;
		    suckyState = SUCKY_STATE_OFF;
		    inClick->state = true;
		    inClick->time = nPgmTime;
		  } else if (joy1Btn(3) == 1 && !outClick->state) {
		    servo[SuckyRight] = SUCKY_SERVO_CCW;
		    servo[SuckyLeft] = SUCKY_SERVO_CW;
		    suckyState = SUCKY_STATE_OUT;
		    outClick->state = true;
		    outClick->time = nPgmTime;
		  }
		  break;

		case SUCKY_STATE_OUT:
		  if (joy1Btn(1) == 1 && !inClick->state) {
		    servo[SuckyRight] = SUCKY_SERVO_CW;
		    servo[SuckyLeft] = SUCKY_SERVO_CCW;
		    suckyState = SUCKY_STATE_IN;
		    inClick->state = true;
		    inClick->time = nPgmTime;
		  } else if (joy1Btn(3) == 1 && !outClick->state) {
		    servo[SuckyRight] = SUCKY_SERVO_OFF;
		    servo[SuckyLeft] = SUCKY_SERVO_OFF;
		    suckyState = SUCKY_STATE_OFF;
		    outClick->state = true;
		    outClick->time = nPgmTime;
		  }
		  break;

		default:
		  break;
  }

  return(suckyState);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the tele-op robot operation. Customize as appropriate for
// your specific robot.
//
// Game controller / joystick information is sent periodically (about every 50 milliseconds) from
// the FMS (Field Management System) to the robot. Most tele-op programs will follow the following
// logic:
//   1. Loop forever repeating the following actions:
//   2. Get the latest game controller / joystick settings that have been received from the PC.
//   3. Perform appropriate actions based on the joystick + buttons settings. This is usually a
//      simple action:
//      *  Joystick values are usually directly translated into power levels for a motor or
//         position of a servo.
//      *  Buttons are usually used to start/stop a motor or cause a servo to move to a specific
//         position.
//   4. Repeat the loop.
//
// Your program needs to continuously loop because you need to continuously respond to changes in
// the game controller settings.
//
// At the end of the tele-op period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

task main()
{
  click moveFWClick, moveBWClick;
  click spinCWClick, spinCCWClick;

  click frontArmFWClick, frontArmBWClick;

  click gripperOpenClick, gripperCloseClick;
  angle gripperLeftAngle, gripperRightAngle;

  click rearArmFWClick, rearArmBWClick;

  click suckyInClick, suckyOutClick;
  int suckyState;

  moveFWClick.state = false;
  moveFWClick.time = nPgmTime;
  moveBWClick.state = false;
  moveBWClick.time = nPgmTime;

  spinCWClick.state = false;
  spinCWClick.time = nPgmTime;
  spinCCWClick.state = false;
  spinCCWClick.time = nPgmTime;

  frontArmFWClick.state = false;
  frontArmFWClick.time = nPgmTime;
  frontArmBWClick.state = false;
  frontArmBWClick.time = nPgmTime;

  gripperOpenClick.state = false;
  gripperOpenClick.time = nPgmTime;
  gripperCloseClick.state = false;
  gripperCloseClick.time = nPgmTime;

  gripperLeftAngle.command = 255;
  gripperLeftAngle.lastUpdateTime = nPgmTime;
  gripperLeftAngle.changeRate = GRIPPER_CHANGE_RATE;
  gripperLeftAngle.posLimit = 255;
  gripperLeftAngle.negLimit = 0;

  gripperRightAngle.command = 0;
  gripperRightAngle.lastUpdateTime = nPgmTime;
  gripperRightAngle.changeRate = GRIPPER_CHANGE_RATE;
  gripperRightAngle.posLimit = 255;
  gripperRightAngle.negLimit = 0;

  rearArmFWClick.state = false;
  rearArmFWClick.time = nPgmTime;
  rearArmBWClick.state = false;
  rearArmBWClick.time = nPgmTime;

  suckyState = SUCKY_STATE_OFF;
  suckyInClick.state = false;
  suckyInClick.time = nPgmTime;
  suckyOutClick.state = false;
  suckyOutClick.time = nPgmTime;

  initializeRobot();

  waitForStart();   // wait for start of tele-op phase

  while (true)
  {
    getJoystickSettings(joystick);
    driveControl(spinCCWClick, spinCWClick, moveFWClick, moveBWClick);
    frontArmControl(frontArmFWClick, frontArmBWClick);
    gripperControl(gripperLeftAngle, gripperRightAngle, gripperOpenClick, gripperCloseClick);
    rearArmControl(rearArmFWClick, rearArmBWClick);
    suckyState = suckyControl(suckyState, suckyInClick, suckyOutClick);
  }
}
